{
  "version": 3,
  "sources": ["api/index.js", "api/wonderland.js"],
  "sourcesContent": ["export * from './wonderland';\r\n\r\n", "const MISALIGNED_MSG = \"Misaligned pointer: please report a bug\";\r\n/* Component class instances per type to avoid GC */\r\nlet ComponentCache = {};\r\n/* Object class instances per type to avoid GC */\r\nlet ObjectCache = [];\r\n\r\n/**\r\n * Wonderland Engine API\r\n * @namespace WL\r\n */\r\n\r\n/**\r\n * @typedef CustomParameter\r\n * @type {object}\r\n * @property {Type} type Parameter type\r\n * @property {*} [default] Default value, depending on type.\r\n * @property {string[]} values Values for {@link Type.Enum}\r\n */\r\n/**\r\n * Register a custom JavaScript component type\r\n *\r\n * @param {string} name Name of the component\r\n * @param {object} params Dict of param names to {@link CustomParameter}\r\n * @param {Component} object Object containing functions for the component type\r\n *\r\n * @example\r\n * registerComponent('my-new-type', {\r\n *  myParam: {type: Type.Float, default: 42.0},\r\n * }, {\r\n *  init: function() {},\r\n *  start: function() {},\r\n *  update: function(dt) {},\r\n *  onActivate: function() {},\r\n *  onDeactivate: function() {},\r\n * });\r\n */\r\nfunction registerComponent(name, params, object) {\r\n    _WL.registerComponent(name, params, object);\r\n};\r\n\r\n/**\r\n * Component parameter type enum\r\n * @enum {number}\r\n */\r\nconst Type = {\r\n    /**\r\n     * **Bool**:\r\n     *\r\n     * Appears in the editor as checkbox.\r\n     */\r\n    Bool: 1<<1,\r\n\r\n    /**\r\n     * **Int**:\r\n     *\r\n     * Appears in the editor as int input field.\r\n     */\r\n    Int: 1<<2,\r\n\r\n    /**\r\n     * **Float**:\r\n     *\r\n     * Appears in the editor as float input field.\r\n     */\r\n    Float: 1<<3,\r\n\r\n    /**\r\n     * **String / Text**:\r\n     *\r\n     * Appears in the editor as text input field.\r\n     */\r\n    String: 1<<4,\r\n\r\n    /**\r\n     * **Enumeration**:\r\n     *\r\n     * Appears in the editor as dropdown with given values.\r\n     * If parameters is enum, a `values` parameter needs to be\r\n     * specified for the parameter aswell.\r\n     *\r\n     * @example\r\n     *     camera: {type: Type.Enum, values: ['auto', 'back', 'front'], default: 'auto'},\r\n     */\r\n    Enum: 1<<5,\r\n\r\n    /**\r\n     * **Object reference**:\r\n     *\r\n     * Appears in the editor as object resource selection dropdown\r\n     * with object picker.\r\n     */\r\n    Object: 1<<6,\r\n\r\n    /**\r\n     * **Mesh reference**:\r\n     *\r\n     * Appears in the editor as mesh resource selection dropdown.\r\n     */\r\n    Mesh: 1<<7,\r\n\r\n    /**\r\n     * **Texture reference**:\r\n     *\r\n     * Appears in the editor as texture resource selection dropdown.\r\n     */\r\n    Texture: 1<<8,\r\n\r\n    /**\r\n     * **Material reference**:\r\n     *\r\n     * Appears in the editor as material resource selection dropdown.\r\n     */\r\n    Material: 1<<9,\r\n\r\n    /**\r\n     * **Animation reference**:\r\n     *\r\n     * Appears in the editor as animation resource selection dropdown.\r\n     */\r\n    Animation: 1<<10,\r\n\r\n    /**\r\n     * **Skin reference**:\r\n     *\r\n     * Appears in the editor as skin resource selection dropdown.\r\n     */\r\n    Skin: 1<<11,\r\n};\r\nexport { Type };\r\n\r\n/**\r\n * Collider type enum for {@link CollisionComponent}\r\n * @enum {number}\r\n */\r\nconst Collider = {\r\n    /**\r\n     * **Sphere Collider**:\r\n     *\r\n     * Simplest and most performant collision shape. If this type is set on a\r\n     * {@link CollisionComponent}, only the first component of\r\n     * {@link CollisionComponent#extents} will be used to determine the radius.\r\n     */\r\n    Sphere: 0,\r\n\r\n    /**\r\n     * **Axis Aligned Bounding Box Collider**:\r\n     *\r\n     * Box that is always aligned to XYZ axis. It cannot be rotated but is more\r\n     * efficient than {@link Collider.Box}.\r\n     */\r\n    AxisAlignedBox: 1,\r\n\r\n    /**\r\n     * **Aligned Bounding Box Collider**:\r\n     *\r\n     * Box that matches the object's rotation and translation correctly. This\r\n     * is the least efficient collider and should only chosen over\r\n     * {@link Collider.Sphere} and {@link Collider.AxisAlignedBox} if really\r\n     * neccessary.\r\n     */\r\n    Box: 2\r\n};\r\nexport { Collider };\r\n\r\n/**\r\n * Alignment type enum for {@link TextComponent}\r\n * @enum {number}\r\n */\r\nconst Alignment = {\r\n    /** Text start is at object origin */\r\n    Left: 1,\r\n\r\n    /** Text center is at object origin */\r\n    Center: 2,\r\n\r\n    /** Text end is at object origin */\r\n    Right: 3\r\n};\r\nexport { Alignment };\r\n\r\n/**\r\n * Justification type enum for {@link TextComponent}\r\n * @enum {number}\r\n */\r\nconst Justification = {\r\n    /** Text line is at object origin */\r\n    Line: 1,\r\n\r\n    /** Text middle is at object origin */\r\n    Middle: 2,\r\n\r\n    /** Text top is at object origin */\r\n    Top: 3\r\n};\r\nexport { Justification };\r\n\r\n/**\r\n * Input type enum for {@link InputComponent}\r\n * @enum {number}\r\n */\r\nconst InputType = {\r\n    /** Head input */\r\n    Head: 0,\r\n\r\n    /** Left eye input */\r\n    EyeLeft: 1,\r\n\r\n    /** Right eye input */\r\n    EyeRight: 2,\r\n\r\n    /** Left controller input */\r\n    ControllerLeft: 3,\r\n\r\n    /** Right controller input */\r\n    ControllerRight: 4,\r\n\r\n    /** Left ray input */\r\n    RayLeft: 5,\r\n\r\n    /** Right ray input */\r\n    RayRight: 6,\r\n};\r\nexport { InputType };\r\n\r\n/**\r\n * Light type enum for {@link LightComponent}\r\n * @enum {number}\r\n */\r\nconst LightType = {\r\n    /** Point light */\r\n    Point: 1,\r\n\r\n    /** Sun light / Directional light */\r\n    Sun: 2,\r\n};\r\nexport { LightType };\r\n\r\n/**\r\n * Animation state of {@link AnimationComponent}\r\n * @enum {number}\r\n */\r\nconst AnimationState = {\r\n    /** Animation is currently playing */\r\n    Playing: 1,\r\n\r\n    /** Animation is paused and will continue at current playback\r\n    * time on {@link AnimationComponent#play} */\r\n    Paused: 2,\r\n\r\n    /** Animation is stopped */\r\n    Stopped: 3\r\n};\r\nexport { AnimationState };\r\n\r\n/**\r\n * Rigid body force mode for {@link PhysXComponent#addForce} and {@link PhysXComponent#addTorque}.\r\n * @enum {number}\r\n *\r\n * [PhysX API Reference](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/structPxForceMode.html)\r\n */\r\nconst ForceMode = {\r\n    /** Apply as force */\r\n    Force: 0,\r\n\r\n    /** Apply as impulse */\r\n    Impulse: 1,\r\n\r\n    /** Apply as velocity change, mass dependent */\r\n    VelocityChange: 2,\r\n\r\n    /** Apply as mass dependent force */\r\n    Acceleration: 3\r\n};\r\nexport { ForceMode };\r\n\r\n/**\r\n * Collision callback event type\r\n * @enum {number}\r\n */\r\nconst CollisionEventType = {\r\n    /** Touch/contact detected, collision */\r\n    Touch: 0,\r\n\r\n    /** Touch/contact lost, uncollide */\r\n    TouchLost: 1,\r\n};\r\nexport { CollisionEventType };\r\n\r\n/**\r\n * Rigid body {@link PhysXComponent#shape|shape}.\r\n * @enum {number}\r\n *\r\n * [PhysX SDK Guide](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html#geometry-types)\r\n */\r\nconst Shape = {\r\n    /** No shape */\r\n    None: 0,\r\n\r\n    /** Sphere shape */\r\n    Sphere: 1,\r\n\r\n    /** Capsule shape */\r\n    Capsule: 2,\r\n\r\n    /** Box shape */\r\n    Box: 3,\r\n\r\n    /** Plane shape */\r\n    Plane: 4,\r\n\r\n    /** Convex mesh shape */\r\n    ConvexMesh: 5,\r\n\r\n    /** Triangle mesh shape */\r\n    TriangleMesh: 6,\r\n};\r\nexport { Shape };\r\n\r\n/**\r\n * Canvas element that Wonderland Engine renders to\r\n * @type {HTMLCanvasElement}\r\n */\r\nlet canvas = null;\r\n\r\n/**\r\n * Current WebXR session or {@link null} if no session active\r\n * @type {XRSession}\r\n */\r\nlet xrSession = null;\r\n/**\r\n * @callback xrSessionStartCallback\r\n * @param {XRSession} session WebXR session that started\r\n */\r\n/**\r\n * @callback xrSessionEndCallback\r\n */\r\n/**\r\n * List of functions to call if a WebXR session is started\r\n * @type {xrSessionStartCallback}\r\n */\r\nconst onXRSessionStart = [ (s) => { xrSession = s; } ];\r\n/**\r\n * List of functions to call if a WebXR session ends\r\n * @type {xrSessionEndCallback}\r\n */\r\nconst onXRSessionEnd = [ () => { xrSession = null; } ];\r\n\r\n/**\r\n * @callback xrSupportCallback\r\n * @param {string} type Type of session which is supported/not supported. Either `\"vr\"` or `\"ar\"`\r\n * @param {boolean} supported Whether given session type is supported\r\n */\r\n/**\r\n * List of functions to call once VR/AR support has been determined.\r\n * @type {xrSupportCallback}\r\n *\r\n * Will be called once for AR and once for VR independent of support for each.\r\n * This allows you to notify the user of both cases: support and missing support of XR.\r\n * See the `supported` parameter of the callback, which indicates support.\r\n */\r\nlet onXRSupported = [\r\n  (type, supported) => {\r\n    if(type == 'ar') arSupported = supported;\r\n    if(type == 'vr') vrSupported = supported;\r\n  }\r\n];\r\n\r\n/**\r\n * @callback sceneLoadedCallback\r\n */\r\n/**\r\n * List of functions to call once the main scene has been loaded\r\n * @type {sceneLoadedCallback}\r\n */\r\nlet onSceneLoaded = [];\r\n\r\n/**\r\n * Whether AR is supported by the browser\r\n *\r\n * `undefined` until support could be determined\r\n */\r\nlet arSupported = undefined;\r\n/**\r\n * Whether VR is supported by the browser\r\n *\r\n * `undefined` until support could be determined\r\n */\r\nlet vrSupported = undefined;\r\n/**\r\n * Current main scene\r\n * @type{Scene}\r\n */\r\nlet scene = undefined;\r\n/**\r\n * Physics, only available when physx is enabled in the runtime\r\n * @type{Physics}\r\n */\r\nlet physics = undefined;\r\n\r\nlet _images = [];\r\nlet _sceneLoadedCallback = [];\r\nlet _tempMem = null;\r\nlet _tempMemSize = 0;\r\nlet _tempMemFloat = null;\r\nlet _tempMemInt = null;\r\nlet _tempMemUint32 = null;\r\nlet _tempMemUint16 = null;\r\nlet _tempMemUint8 = null;\r\n\r\n/** Initialize API resources, called by the engine automatically. */\r\nfunction init() {\r\n    scene = new Scene();\r\n    /* For internal testing, we provide compatibility with DOM-less execution */\r\n    canvas = (typeof document === 'undefined') ? null : document.getElementById('canvas');\r\n\r\n    ComponentCache = {};\r\n    /* Object class instances per type to avoid GC */\r\n    ObjectCache = [];\r\n\r\n    /* Target memory for JS API functions that return arrays */\r\n    allocateTempMemory(1024);\r\n}\r\n\r\n/** Initialize API resources, called by the engine automatically, if\r\n * PhysX is enabled. */\r\nfunction _initPhysics() {\r\n    physics = new Physics();\r\n}\r\n\r\nfunction allocateTempMemory(size) {\r\n    console.log(\"Allocating temp mem:\", size);\r\n    _tempMemSize = size;\r\n    if(_tempMem) _free(_tempMem);\r\n    _tempMem = _malloc(_tempMemSize);\r\n    updateTempMemory();\r\n}\r\n\r\nfunction requireTempMem(size) {\r\n    if(_tempMemSize < size) {\r\n        /* Grow in 1kb increments */\r\n        allocateTempMemory(Math.ceil(size/1024)*1024);\r\n    }\r\n}\r\n\r\nfunction updateTempMemory() {\r\n    _tempMemFloat = new Float32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\r\n    _tempMemInt = new Int32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\r\n    _tempMemUint32 = new Uint32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\r\n    _tempMemUint16 = new Uint16Array(HEAP8.buffer,_tempMem,_tempMemSize >> 1);\r\n    _tempMemUint8 = new Uint8Array(HEAP8.buffer,_tempMem,_tempMemSize);\r\n}\r\n\r\nexport {\r\n    registerComponent,\r\n\r\n    canvas,\r\n    scene,\r\n    xrSession,\r\n    onXRSessionStart,\r\n    onXRSessionEnd,\r\n    onXRSupported,\r\n    onSceneLoaded,\r\n    arSupported,\r\n    vrSupported,\r\n    physics,\r\n    _images,\r\n    _sceneLoadedCallback,\r\n    textures,\r\n\r\n    init,\r\n    _initPhysics,\r\n    updateTempMemory,\r\n};\r\n\r\n/**\r\n * Provides global scene functionality like raycasting.\r\n */\r\nclass Scene {\r\n    constructor() {\r\n        this._rayHit = _malloc(4*(3*4+3*4+4+2)+4);\r\n        this._hit = new RayHit(this._rayHit);\r\n\r\n        /* Hidden property, list of functions to call after a\r\n         * frame has been rendered */\r\n        this.onPreRender = [];\r\n        this.onPostRender = [];\r\n    }\r\n\r\n    /**\r\n     * @returns {ViewComponent[]} currently active view components\r\n     */\r\n    get activeViews() {\r\n        const count = _wl_scene_get_active_views(_tempMem, 16);\r\n\r\n        const views = [];\r\n        const viewTypeIndex = $Object._typeIndexFor(\"view\");\r\n        for(let i = 0; i < count; ++i) {\r\n            views.push(new ViewComponent(viewTypeIndex, _tempMemInt[i]));\r\n        }\r\n\r\n        return views;\r\n    }\r\n\r\n    /**\r\n     * Cast a ray through the scene and find intersecting objects.\r\n     *\r\n     * The resulting ray hit will contain up to **4** closest ray hits,\r\n     * sorted by increasing distance.\r\n     *\r\n     * @param {number[]} o Ray origin\r\n     * @param {number[]} d Ray direction\r\n     * @param {number} group Collision group to filter by: only objects that are\r\n     *        part of given group are considered for raycast.\r\n     *\r\n     * @note The returned {@link RayHit} object is owned by the Scene instance and\r\n     *       will be reused with the next {@link Scene#rayCast} call.\r\n     */\r\n    rayCast(o, d, group) {\r\n        _wl_scene_ray_cast(\r\n            o[0], o[1], o[2],\r\n            d[0], d[1], d[2],\r\n            group, this._rayHit);\r\n        return this._hit;\r\n    }\r\n\r\n    /**\r\n     * Add object to the scene\r\n     *\r\n     * @param {$Object} parent Parent object or {@link null}\r\n     * @returns {$Object} newly created object\r\n     */\r\n    addObject(parent) {\r\n        const parentId = parent ? parent.objectId : 0;\r\n        const objectId = _wl_scene_add_object(parentId);\r\n        return $Object._wrapObject(objectId);\r\n    }\r\n\r\n    /**\r\n     * Batch-add objects to the scene\r\n     *\r\n     * Will provide better performance for adding multiple objects (e.g. > 16)\r\n     * than calling {@link Scene#addObject} repeatidly in a loop.\r\n     *\r\n     * By providing upfront information of how many objects will be required,\r\n     * the engine is able to batch-allocate the required memory rather than\r\n     * convervatively grow the memory in small steps.\r\n     *\r\n     * **Experimental:** This API might change in upcoming versions.\r\n     *\r\n     * @param {number} count Number of objects to add\r\n     * @param {$Object} parent Parent object or {@link null}, default {@link null}\r\n     * @param {number} componentCountHint Hint for how many components in total will\r\n     *      be added to the created objects afterwards, default `0`.\r\n     * @returns {$Object[]} newly created objects\r\n     */\r\n    addObjects(count, parent, componentCountHint) {\r\n        const parentId = parent ? parent.objectId : 0;\r\n        requireTempMem(count*2);\r\n        const actualCount = _wl_scene_add_objects(parentId, count, componentCountHint || 0, _tempMem, _tempMemSize >> 1);\r\n        const ids = _tempMemUint16.subarray(0, actualCount);\r\n        const objects = Array.from(ids, $Object._wrapObject);\r\n        return objects;\r\n    }\r\n\r\n    /**\r\n     * Set the background clear color\r\n     *\r\n     * @param {number[]} color new clear color (RGBA)\r\n     * @since 0.8.5\r\n     */\r\n    set clearColor(color) {\r\n        _wl_scene_set_clearColor(color[0], color[1], color[2], color[3]);\r\n    }\r\n\r\n    /**\r\n     * Load a scene file (.bin)\r\n     *\r\n     * Will replace the currently active scene with the one loaded\r\n     * from given file. It is assumed that JavaScript components required by\r\n     * the new scene were registered in advance.\r\n     *\r\n     * @param filename Path to the .bin file\r\n     */\r\n    load(filename) {\r\n        const strLen = lengthBytesUTF8(filename) + 1;\r\n        const ptr = _malloc(strLen);\r\n        stringToUTF8(filename, ptr, strLen);\r\n        _wl_load_scene(ptr);\r\n        _free(ptr);\r\n    }\r\n\r\n    /**\r\n     * Load a external 3D file (.gltf, .glb)\r\n     *\r\n     * Loads and parses the gltf file and its images and appends the result\r\n     * to scene.\r\n     *\r\n     * @param filename Path to the .gltf or .glb file\r\n     * @returns {Promise<$Object>} Root of the loaded scene\r\n     */\r\n    append(filename) {\r\n        const strLen = lengthBytesUTF8(filename) + 1;\r\n        const ptr = _malloc(strLen);\r\n        stringToUTF8(filename, ptr, strLen);\r\n        const callback = _sceneLoadedCallback.length;\r\n        const promise = new Promise((resolve, reject) => {\r\n            _sceneLoadedCallback[callback] = {\r\n                success: (id) => resolve($Object._wrapObject(id)),\r\n                error: () => reject()\r\n            };\r\n        });\r\n        _wl_append_scene(ptr, callback);\r\n        _free(ptr);\r\n        return promise;\r\n    }\r\n};\r\nexport { Scene };\r\n\r\n/**\r\n * Native component\r\n *\r\n * Provides access to a native component instance of a specified component type\r\n */\r\nclass Component {\r\n    constructor(managerIndex, id) {\r\n        this._id = id;\r\n        this._manager = managerIndex;\r\n    }\r\n\r\n    /**\r\n     * @returns {string} the name of this component's type\r\n     */\r\n    get type() {\r\n        return this._type || $Object._typeNameFor(this._manager);\r\n    }\r\n\r\n    /**\r\n     * @returns {$Object} The object this component is attached to\r\n     */\r\n    get object() {\r\n        const objectId = _wl_component_get_object(this._manager, this._id);\r\n        return $Object._wrapObject(objectId);\r\n    }\r\n\r\n    /**\r\n     * Set whether this component is active\r\n     *\r\n     * Activating/deactivating a component comes at a small cost of reordering\r\n     * components in the respective component manager. This function therefore\r\n     * is not a trivial assignment.\r\n     *\r\n     * Does nothing if the component is already activated/deactivated.\r\n     *\r\n     * @param {boolean} active New active state\r\n     */\r\n    set active(active) {\r\n        _wl_component_setActive(this._manager, this._id, active);\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean} Whether this component is active\r\n     */\r\n    get active() {\r\n        return _wl_component_isActive(this._manager, this._id) != 0;\r\n    }\r\n\r\n    /**\r\n     * Checks equality by comparing whether the wrapped native component ids\r\n     * and component manager types are equal.\r\n     *\r\n     * @param {?Component} otherComponent Component to check equality with\r\n     * @returns {boolean} Whether this component equals the given component\r\n     */\r\n    equals(otherComponent) {\r\n        if(!otherComponent) return false;\r\n        return this._manager == otherComponent._manager && this._id == otherComponent._id;\r\n    }\r\n};\r\nexport { Component };\r\n\r\n/**\r\n * Native collision component\r\n *\r\n * Provides access to a native collision component instance\r\n */\r\nclass CollisionComponent extends Component {\r\n\r\n    /**\r\n     * @returns {Collider} Collision component collider\r\n     */\r\n    get collider() {\r\n        return _wl_collision_component_get_collider(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set collision component collider\r\n     *\r\n     * @param {Collider} collider Collider of the collision component.\r\n     */\r\n    set collider(collider) {\r\n        _wl_collision_component_set_collider(this._id, collider);\r\n    }\r\n\r\n    /**\r\n     * If {@link CollisionComponent#collider} returns {@link Collider.Sphere}, only the first\r\n     * component of the returned vector is used.\r\n     *\r\n     * @returns {number[]} Collision component extents\r\n    */\r\n    get extents() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_collision_component_get_extents(this._id), 3);\r\n    }\r\n\r\n    /**\r\n     * Set collision component extents\r\n     *\r\n     * If {@link CollisionComponent#collider} returns {@link Collider.Sphere}, only the first\r\n     * component of the passed vector is used.\r\n     *\r\n     * @param {number[]} extents Extents of the collision component, expects a\r\n     *      3 component array.\r\n     */\r\n    set extents(extents) {\r\n        this.extents.set(extents);\r\n    }\r\n\r\n    /**\r\n     * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}\r\n     * or the group in {@link Scene#rayCast}.\r\n     *\r\n     * Colliders that have no common groups will not overlap with each other. If a collider\r\n     * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.\r\n     *\r\n     * Each bit represents belonging to a group, see example.\r\n     *\r\n     * @example\r\n     *    // c belongs to group 2\r\n     *    c.group = (1 << 2);\r\n     *\r\n     *    // c belongs to group 0\r\n     *    c.group = (1 << 0);\r\n     *\r\n     *    // c belongs to group 0 *and* 2\r\n     *    c.group = (1 << 0) | (1 << 2);\r\n     *\r\n     *    (c.group & (1 << 2)) != 0; // true\r\n     *    (c.group & (1 << 7)) != 0; // false\r\n     *\r\n     * @returns {number} collision component group\r\n     */\r\n    get group() {\r\n        return _wl_collision_component_get_group(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set collision component group\r\n     *\r\n     * @param {number} group Group mask of the collision component\r\n     */\r\n    set group(group) {\r\n        _wl_collision_component_set_group(this._id, group);\r\n    }\r\n\r\n    /**\r\n     * Query overlapping objects\r\n     *\r\n     * @returns {CollisionComponent[]} Collision components overlapping this collider.\r\n     */\r\n    queryOverlaps() {\r\n        const count = _wl_collision_component_query_overlaps(this._id, _tempMem, _tempMemSize >> 1);\r\n        let overlaps = new Array(count);\r\n        for(let i = 0; i < count; ++i) {\r\n            overlaps[i] = new CollisionComponent(this._manager, _tempMemUint16[i]);\r\n        }\r\n        return overlaps;\r\n    }\r\n};\r\nexport { CollisionComponent };\r\n\r\n/**\r\n * Native text component\r\n *\r\n * Provides access to a native text component instance\r\n */\r\nclass TextComponent extends Component {\r\n\r\n    /**\r\n     * @returns {Alignment} Text component alignment\r\n     */\r\n    get alignment() {\r\n        return _wl_text_component_get_alignment(this._id) & 7;\r\n    }\r\n\r\n    /**\r\n     * Set text component alignment\r\n     *\r\n     * @param {Alignment} alignment Alignment for the text component.\r\n     */\r\n    set alignment(alignment) {\r\n        _wl_text_component_set_alignment(this._id, this.justification << 3 | alignment);\r\n    }\r\n\r\n    /**\r\n     * @returns {Justification} Text component justification\r\n     */\r\n    get justification() {\r\n        return _wl_text_component_get_alignment(this._id) >> 3;\r\n    }\r\n\r\n    /**\r\n     * Set text component justification\r\n     *\r\n     * @param {Justification} justification Justification for the text component.\r\n     */\r\n    set justification(justification) {\r\n        _wl_text_component_set_alignment(this._id, justification << 3 | this.alignment);\r\n    }\r\n\r\n    /**\r\n     * @returns {string} Text component text\r\n     */\r\n    get text() {\r\n        return UTF8ToString(_wl_text_component_get_text(this._id));\r\n    }\r\n\r\n    /**\r\n     * Set text component text\r\n     *\r\n     * @param {string} text Text of the text component\r\n     */\r\n    set text(text) {\r\n        const strLen = lengthBytesUTF8(text) + 1;\r\n        const ptr = _malloc(strLen);\r\n        stringToUTF8(text, ptr, strLen);\r\n        _wl_text_component_set_text(this._id, ptr);\r\n        _free(ptr);\r\n    }\r\n\r\n    /**\r\n     * Set material to render the text with\r\n     *\r\n     * @param {Material} material New material\r\n     */\r\n    set material(material) {\r\n        _wl_text_component_set_material(this._id, material._index);\r\n    }\r\n\r\n    /**\r\n     * @returns {?Material} Material used to render the text\r\n     */\r\n    get material() {\r\n        return Material.wrap(_wl_text_component_get_material(this._id));\r\n    }\r\n\r\n};\r\nexport { TextComponent };\r\n\r\n/**\r\n * Native view component\r\n *\r\n * Provides access to a native view component instance\r\n */\r\nclass ViewComponent extends Component {\r\n\r\n    /**\r\n     * @returns {Float32Array} Projection matrix\r\n     */\r\n    get projectionMatrix() {\r\n        return new Float32Array(HEAPF32.buffer,\r\n            _wl_view_component_get_projection_matrix(this._id), 16);\r\n    }\r\n};\r\nexport { ViewComponent };\r\n\r\n/**\r\n * Native input component\r\n *\r\n * Provides access to a native input component instance\r\n */\r\nclass InputComponent extends Component {\r\n\r\n    /**\r\n     * @returns {InputType} Input component type\r\n     */\r\n    get inputType() {\r\n        return _wl_input_component_get_type(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set input component type\r\n     *\r\n     * @params {InputType} New input component type\r\n     */\r\n    set inputType(type) {\r\n        _wl_input_component_set_type(this._id, type);\r\n    }\r\n\r\n    /**\r\n     * @returns {?XRInputSource} WebXR Device API input source associated\r\n     *          with this input component, if type {@link InputType.ControllerLeft}\r\n     *          or {@link InputType.ControllerRight}.\r\n     */\r\n    get xrInputSource() {\r\n        if(xrSession) {\r\n            for(let inputSource of xrSession.inputSources) {\r\n                if(inputSource.handedness == this.handedness) {\r\n                    return inputSource;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @returns {?string} 'left', 'right' or {@link null} depending on the {@link InputComponent#inputType}.\r\n     */\r\n    get handedness() {\r\n        const inputType = this.inputType;\r\n        if(inputType == InputType.ControllerRight || inputType == InputType.RayRight || inputType == InputType.EyeRight)\r\n            return 'right';\r\n        if(inputType == InputType.ControllerLeft || inputType == InputType.RayLeft || inputType == InputType.EyeLeft)\r\n            return 'left';\r\n\r\n        return null;\r\n    }\r\n};\r\nexport { InputComponent };\r\n\r\n/**\r\n * Native light component\r\n *\r\n * Provides access to a native light component instance\r\n */\r\nclass LightComponent extends Component {\r\n\r\n    /** @returns {Float32Array} View on the light color */\r\n    get color() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_light_component_get_color(this._id), 4);\r\n    }\r\n\r\n    /** @returns {LightType} Light type */\r\n    get lightType() {\r\n        return _wl_light_component_get_type(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set light type\r\n     *\r\n     * @param {LightType} lightType Type of the light component.\r\n     */\r\n    set lightType(t) {\r\n        return _wl_light_component_set_type(this._id, t);\r\n    }\r\n};\r\nexport { LightComponent };\r\n\r\n/**\r\n * Native animation component\r\n *\r\n * Provides access to a native animation component instance\r\n */\r\nclass AnimationComponent extends Component {\r\n\r\n    /**\r\n     * Set animation to play\r\n     *\r\n     * Make sure to {@link Animation#retarget} the animation to affect the\r\n     * right objects.\r\n     *\r\n     * @param {Animation} animation to play\r\n     */\r\n    set animation(anim) {\r\n        _wl_animation_component_set_animation(this._id, anim._index);\r\n    }\r\n\r\n    /** @returns {Animation} animation set for this component */\r\n    get animation() {\r\n        return new Animation(_wl_animation_component_get_animation(this._id));\r\n    }\r\n\r\n    /**\r\n     * Set play count. Set to `0` to loop indefinitely.\r\n     *\r\n     * @param {number} playCount Number of times to repeat the animation\r\n     */\r\n    set playCount(playCount) {\r\n        _wl_animation_component_set_playCount(this._id, playCount);\r\n    }\r\n\r\n    /** @returns {number} Number of times the animation is played */\r\n    get playCount() {\r\n        return _wl_animation_component_get_playCount(this._id);\r\n    }\r\n\r\n    /** Play animation */\r\n    play() {\r\n        _wl_animation_component_play(this._id);\r\n    }\r\n\r\n    /** Stop animation */\r\n    stop() {\r\n        _wl_animation_component_stop(this._id);\r\n    }\r\n\r\n    /** Pause animation */\r\n    pause() {\r\n        _wl_animation_component_pause(this._id);\r\n    }\r\n\r\n    /** @returns {AnimationState} Current playing state of the animation */\r\n    get state() {\r\n        return _wl_animation_component_state(this._id);\r\n    }\r\n\r\n};\r\nexport { AnimationComponent };\r\n\r\n/**\r\n * Native mesh component\r\n *\r\n * Provides access to a native mesh component instance\r\n */\r\nclass MeshComponent extends Component {\r\n    /**\r\n     * Set material to render the mesh with\r\n     *\r\n     * @param {?Material} material Material to render the mesh with\r\n     */\r\n    set material(material) {\r\n        _wl_mesh_component_set_material(this._id, material._index);\r\n    }\r\n\r\n    /** @returns {?Material} Material used to render the mesh */\r\n    get material() {\r\n        return Material.wrap(_wl_mesh_component_get_material(this._id));\r\n    }\r\n\r\n    /** @returns {?Mesh} Mesh rendered by this component */\r\n    get mesh() {\r\n        return new Mesh(_wl_mesh_component_get_mesh(this._id));\r\n    }\r\n\r\n    /**\r\n     * Set mesh to rendered with this component\r\n     *\r\n     * @param {?Mesh} mesh Mesh rendered by this component\r\n     */\r\n    set mesh(mesh) {\r\n        _wl_mesh_component_set_mesh(this._id, mesh._index);\r\n    }\r\n\r\n    /** @returns {?Skin} Skin for this mesh component */\r\n    get skin() {\r\n        return new Skin(_wl_mesh_component_get_skin(this._id));\r\n    }\r\n\r\n    /**\r\n     * Set skin to transform this mesh component\r\n     *\r\n     * @param {?Skin} skin Skin to use for rendering skinned meshes\r\n     */\r\n    set skin(skin) {\r\n        _wl_mesh_component_set_skin(this._id, skin._index);\r\n    }\r\n};\r\nexport { MeshComponent };\r\n\r\n/**\r\n * Native physx rigid body component\r\n *\r\n * Provides access to a native mesh component instance.\r\n * Only available when using physx enabled runtime, see \"Project Settings > Runtime\".\r\n */\r\nclass PhysXComponent extends Component {\r\n    /**\r\n     * Set whether this rigid body is static\r\n     *\r\n     * Setting this property only takes effect once the component\r\n     * switches from inactive to active.\r\n     *\r\n     * @param {boolean} b Whether the rigid body should be static\r\n     */\r\n    set static(b) {\r\n        _wl_physx_component_set_static(this._id, b);\r\n    }\r\n\r\n    /**\r\n     * Whether this rigid body is static\r\n     *\r\n     * This property returns whether the rigid body is *effectively*\r\n     * static. If static property was set while the rigid body was\r\n     * active, it will not take effect until the rigid body is set\r\n     * inactive and active again. Until the component is set inactive,\r\n     * this getter will return whether the rigidbody is actually\r\n     * static.\r\n     */\r\n    get static() {\r\n        return !!_wl_physx_component_get_static(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set whether this rigid body is kinematic\r\n     *\r\n     * @param {boolean} b Whether the rigid body should be kinematic\r\n     */\r\n    set kinematic(b) {\r\n        _wl_physx_component_set_kinematic(this._id, b);\r\n    }\r\n\r\n    /**\r\n     * Whether this rigid body is kinematic\r\n     */\r\n    get kinematic() {\r\n        return !!_wl_physx_component_get_kinematic(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set the shape for collision detection\r\n     *\r\n     * @param {Shape} s New shape\r\n     * @since 0.8.5\r\n     */\r\n    set shape(s) {\r\n        _wl_physx_component_set_shape(this._id, s);\r\n    }\r\n\r\n    /**\r\n     * The shape for collision detection\r\n     */\r\n    get shape() {\r\n        return _wl_physx_component_get_shape(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set the shape extents for collision detection\r\n     *\r\n     * @param {number[]} e New extents for the shape\r\n     * @since 0.8.5\r\n     */\r\n    set extents(e) {\r\n        this.extents.set(e);\r\n    }\r\n\r\n    /**\r\n     * The shape extents for collision detection\r\n     */\r\n    get extents() {\r\n        const ptr = _wl_physx_component_get_extents(this._id);\r\n        return new Float32Array(HEAPF32.buffer, ptr, 3);\r\n    }\r\n\r\n    /**\r\n     * Get staticFriction\r\n     */\r\n    get staticFriction() {\r\n        return _wl_physx_component_get_staticFriction(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set staticFriction\r\n     * @param {number} v New staticFriction\r\n     */\r\n    set staticFriction(v) {\r\n        _wl_physx_component_set_staticFriction(this._id, v);\r\n    }\r\n\r\n    /**\r\n     * Get dynamicFriction\r\n     */\r\n    get dynamicFriction() {\r\n        return _wl_physx_component_get_dynamicFriction(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set dynamicFriction\r\n     * @param {number} v New dynamicDamping\r\n     */\r\n    set dynamicFriction(v) {\r\n        _wl_physx_component_set_dynamicFriction(this._id, v);\r\n    }\r\n\r\n    /**\r\n     * Get restitution\r\n     */\r\n    get restitution() {\r\n        return _wl_physx_component_get_restitution(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set restitution\r\n     * @param {number} v New restitution\r\n     */\r\n    set restitution(v) {\r\n        _wl_physx_component_set_restitution(this._id, v);\r\n    }\r\n\r\n    /**\r\n     * Get linearDamping\r\n     */\r\n    get linearDamping() {\r\n        return _wl_physx_component_get_linearDamping(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set linearDamping\r\n     * @param {number} v New linearDamping\r\n     */\r\n    set linearDamping(v) {\r\n        _wl_physx_component_set_linearDamping(this._id, v);\r\n    }\r\n\r\n    /**\r\n     * Get angularDamping\r\n     */\r\n    get angularDamping() {\r\n        return _wl_physx_component_get_angularDamping(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set angularDamping\r\n     * @param {number} v New angularDamping\r\n     */\r\n    set angularDamping(v) {\r\n        _wl_physx_component_set_angularDamping(this._id, v);\r\n    }\r\n\r\n    /**\r\n     * Set linear velocity\r\n     *\r\n     * [PhysX Manual - \"Velocity\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)\r\n     *\r\n     * @param {number[]} v New linear velocity\r\n     */\r\n    set linearVelocity(v) {\r\n        _wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /** @returns {Float32Array} Linear velocity */\r\n    get linearVelocity() {\r\n        _wl_physx_component_get_linearVelocity(this._id, _tempMem);\r\n        return new Float32Array(HEAPF32.buffer, _tempMem, 3);\r\n    }\r\n\r\n    /**\r\n     * Set angular velocity\r\n     *\r\n     * [PhysX Manual - \"Velocity\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)\r\n     *\r\n     * @param {number[]} v New angular velocity\r\n     */\r\n    set angularVelocity(v) {\r\n        _wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /** @returns {Float32Array} Linear velocity */\r\n    get angularVelocity() {\r\n        _wl_physx_component_get_angularVelocity(this._id, _tempMem);\r\n        return new Float32Array(HEAPF32.buffer, _tempMem, 3);\r\n    }\r\n\r\n    /**\r\n     * Set mass\r\n     *\r\n     * [PhysX Manual - \"Mass Properties\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)\r\n     *\r\n     * @param {number} m New mass\r\n     */\r\n    set mass(m) {\r\n        _wl_physx_component_set_mass(this._id, m);\r\n    }\r\n\r\n    /** @returns {number} mass */\r\n    get mass() {\r\n        return _wl_physx_component_get_mass(this._id);\r\n    }\r\n\r\n    /**\r\n     * Set mass space interia tensor\r\n     *\r\n     * [PhysX Manual - \"Mass Properties\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)\r\n     *\r\n     * @param {number[]} v New mass space interatia tensor\r\n     */\r\n    set massSpaceInteriaTensor(v) {\r\n        _wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * Apply a force\r\n     *\r\n     * [PhysX Manual - \"Applying Forces and Torques\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)\r\n     *\r\n     * @param {number[]} f Force vector\r\n     * @param {number[]} m Force mode, see {@link ForceMode}, default `Force`.\r\n     * @param {number[]} localForce Whether the force vector is in local space, default `false`.\r\n     * @param {number[]} p Position to apply force at, default is center of mass.\r\n     * @param {number[]} local Whether position is in local space, default `false`.\r\n     */\r\n    addForce(f, m, localForce, p, local) {\r\n        m = m || ForceMode.Force;\r\n        if(!p) {\r\n            _wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, !!localForce);\r\n        } else {\r\n            _wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, !!localForce, p[0], p[1], p[2], !!local);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply torque\r\n     *\r\n     * [PhysX Manual - \"Applying Forces and Torques\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)\r\n     *\r\n     * @param {number[]} f Force vector\r\n     * @param {number[]} m Force mode, see {@link ForceMode}, default `Force`.\r\n     */\r\n    addTorque(f, m) {\r\n        m = m || ForceMode.Force;\r\n        _wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);\r\n    }\r\n\r\n    /**\r\n     * @callback collisionCallback\r\n     * @param {CollisionEventType} type Type of the event\r\n     * @param {PhysXComponent} other Other component that was (un)collided with\r\n     */\r\n    /**\r\n     * Add on collision callback\r\n     *\r\n     * @param {collisionCallback} callback Function to call when this rigid body\r\n     *        (un)collides with any other.\r\n     *\r\n     * @example\r\n     *  let rigidBody = this.object.getComponent('physx');\r\n     *  rigidBody.onCollision(function(type, other) {\r\n     *      // Ignore uncollides\r\n     *      if(type == CollisionEventType.TouchLost) return;\r\n     *\r\n     *      // Take damage on collision with enemies\r\n     *      if(other.object.name.startsWith('enemy-')) {\r\n     *          this.applyDamage(10);\r\n     *      }\r\n     *  }.bind(this));\r\n     */\r\n    onCollision(callback) {\r\n        this.onCollisionWith(this, callback);\r\n    }\r\n\r\n    /**\r\n     * Add filtered on collision callback\r\n     *\r\n     * @param {PhysXComponent} otherComp Component for which callbacks will\r\n     *        be triggered. If you pass this component, the method is equivalent to\r\n     *        {@link PhysXComponent#onCollision}.\r\n     * @param {collisionCallback} callback Function to call when this rigid body\r\n     *        (un)collides with `otherComp`.\r\n     */\r\n    onCollisionWith(otherComp, callback) {\r\n        physics._callbacks[this._id] = physics._callbacks[this._id] || [];\r\n        physics._callbacks[this._id].push(callback);\r\n        _wl_physx_component_addCallback(this._id, otherComp._id || this._id);\r\n    }\r\n};\r\nexport { PhysXComponent };\r\n\r\n/**\r\n * Access to the physics scene\r\n */\r\nclass Physics {\r\n    constructor() {\r\n        this._rayHit = _malloc(4*(3*4+3*4+4+2)+4);\r\n        this._hit = new RayHit(this._rayHit);\r\n        this._callbacks = {};\r\n    }\r\n\r\n    /**\r\n     * Cast a ray through the physics scene and find intersecting objects.\r\n     *\r\n     * The resulting ray hit will contain **up to 4** closest ray hits,\r\n     * sorted by increasing distance.\r\n     *\r\n     * @param {number[]} o Ray origin\r\n     * @param {number[]} d Ray direction\r\n     * @param {number} group Collision group to filter by: only objects that are\r\n     *        part of given group are considered for raycast.\r\n     * @param {number} maxDistance Maxium ray distance, default `100.0`.\r\n     *\r\n     * @note The returned {@link RayHit} object is owned by the Physics instance and\r\n     *       will be reused with the next {@link Physics#rayCast} call.\r\n     */\r\n    rayCast(o, d, group, maxDistance) {\r\n        if(typeof maxDistance === 'undefined') maxDistance = 100.0;\r\n        _wl_physx_ray_cast(\r\n            o[0], o[1], o[2],\r\n            d[0], d[1], d[2],\r\n            group, maxDistance||100, this._rayHit);\r\n        return this._hit;\r\n    }\r\n\r\n    _callCollisionCallback(a, index, type, b) {\r\n        physics._callbacks[a][index](type,\r\n            new PhysXComponent($Object._typeIndexFor('physx'), b));\r\n    }\r\n};\r\nexport { Physics };\r\n\r\n/**\r\n * Wrapper around a native mesh data\r\n */\r\nclass Mesh {\r\n    /** Size of a vertex in float elements */\r\n    static get VERTEX_FLOAT_SIZE() { return 3 + 3 + 2; }\r\n    /** Size of a vertex in bytes */\r\n    static get VERTEX_SIZE() { return this.VERTEX_FLOAT_SIZE*4; }\r\n\r\n    /** Position attribute offsets in float elements */\r\n    static get POS() { return { X: 0, Y: 1, Z: 2 }; }\r\n    /** Texture coordinate attribute offsets in float elements */\r\n    static get TEXCOORD() { return { U: 3, V: 4 }; }\r\n    /** Normal attribute offsets in float elements */\r\n    static get NORMAL() { return { X: 5, Y: 6, Z: 7 }; }\r\n\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param params Either index to wrap or set of parameters to create a new mesh\r\n     * @param {number[]} params.indexData Index data values\r\n     * @param {MeshIndexType} params.indexType Index type\r\n     * @param {number[]} params.vertexData Interleaved vertex data values. A vertex is a set of 8 float values:\r\n     *          - 0-3 Position\r\n     *          - 4-7 Normal\r\n     *          - 7-8 Texture Coordinate\r\n     */\r\n    constructor(params) {\r\n        if(typeof(params) === 'object') {\r\n            params.indexType = params.indexType || MeshIndexType.UnsignedShort;\r\n            let indexData = _malloc(params.indexData.length*params.indexType);\r\n            let vertexData = _malloc(params.vertexData.length*4 /* sizeof(float) */);\r\n\r\n            switch(params.indexType) {\r\n                case MeshIndexType.UnsignedByte:\r\n                    HEAPU8.set(params.indexData, indexData);\r\n                    break;\r\n                case MeshIndexType.UnsignedShort:\r\n                    HEAPU16.set(params.indexData, indexData >> 1);\r\n                    break;\r\n                case MeshIndexType.UnsignedInt:\r\n                    HEAPU32.set(params.indexData, indexData >> 2);\r\n                    break;\r\n            }\r\n            HEAPF32.set(params.vertexData, vertexData >> 2);\r\n            this._index = _wl_mesh_create(indexData,\r\n                params.indexData.length*params.indexType,\r\n                params.indexType,\r\n                vertexData,\r\n                params.vertexData.length*4 /* sizeof(float) */);\r\n\r\n        } else {\r\n            this._index = params;\r\n        }\r\n    }\r\n\r\n    /** @returns {Float32Array} Vertex data */\r\n    get vertexData() {\r\n        let ptr = _wl_mesh_get_vertexData(this._index, _tempMem);\r\n        return new Float32Array(HEAPF32.buffer, ptr, WL.Mesh.VERTEX_FLOAT_SIZE*HEAPU32[_tempMem/4]);\r\n    }\r\n\r\n    /** @returns {Uint8Array|Uint16Array|Uint32Array} Vertex data */\r\n    get indexData() {\r\n        let ptr = _wl_mesh_get_indexData(this._index, _tempMem, _tempMem + 4);\r\n        const indexCount = HEAPU32[_tempMem/4];\r\n        const indexSize = HEAPU32[_tempMem/4 + 1];\r\n        switch(indexSize) {\r\n            case UnsignedByte:\r\n                return new Uint8Array(HEAPU8.buffer, ptr, indexCount);\r\n            case UnsignedShort:\r\n                return new Uint16Array(HEAPU16.buffer, ptr, indexCount);\r\n            case UnsignedInt:\r\n                return new Uint32Array(HEAPU32.buffer, ptr, indexCount);\r\n        }\r\n    }\r\n};\r\nexport { Mesh };\r\n\r\n/**\r\n * Mesh index type\r\n * @enum {number}\r\n */\r\nconst MeshIndexType = {\r\n    /** Single byte mesh index, range 0-255 */\r\n    UnsignedByte: 1,\r\n\r\n    /** Two byte mesh index, range 0-65535 */\r\n    UnsignedShort: 2,\r\n\r\n    /** Four byte mesh index, range 0-4294967295 */\r\n    UnsignedInt: 4,\r\n};\r\nexport { MeshIndexType };\r\n\r\n/**\r\n * Wrapper around a native material\r\n */\r\nclass Material {\r\n    /**\r\n     * Create a new Material. Used internally by {@link Material.wrap}.\r\n     *\r\n     * @note Do not use this constructor directly, rather use\r\n     *     {@link Material#clone} or {@link Material.wrap} to create instances.\r\n     */\r\n    constructor(index) {\r\n        this._index = index;\r\n    }\r\n\r\n    /**\r\n     * @returns {string} Name of the shader used by this material\r\n     */\r\n    get shader() {\r\n        return UTF8ToString(_wl_material_get_shader(this._index));\r\n    }\r\n\r\n    /**\r\n     * Create a copy of the underlying native material and {@link Material.wrap} the result\r\n     * @returns {Material} Material clone\r\n     */\r\n    clone() {\r\n        return Material.wrap(_wl_material_clone(this._index));\r\n    }\r\n\r\n    _paramIndex(name) {\r\n        const lengthBytes = lengthBytesUTF8(name) + 1;\r\n        const mem = _malloc(lengthBytes);\r\n        stringToUTF8(name, mem, lengthBytes);\r\n        const index = _wl_material_get_param_index(this._index, mem);\r\n        _free(mem);\r\n        return index;\r\n    }\r\n\r\n    _paramType(paramIndex) {\r\n        const t = _wl_material_get_param_type(this._index, paramIndex);\r\n        return {type: (t & 0xFF), componentCount: ((t >> 8) & 0xFF), metaType: ((t >> 16) & 0xFF)};\r\n    }\r\n\r\n    /**\r\n     * Wrap a native material index\r\n     * @param {number} index\r\n     * @returns {Material} Material instance or {@link null} if index <= 0.\r\n     */\r\n    static wrap(index) {\r\n        if(index <= 0) return null;\r\n\r\n        const material = new Material(index);\r\n        return new Proxy(material, {\r\n            get(target, prop) {\r\n                const paramIndex = target._paramIndex(prop);\r\n                if (paramIndex != -1) {\r\n                    const paramType = target._paramType(paramIndex);\r\n                    if(_wl_material_get_param_value(target._index, paramIndex, _tempMem)) {\r\n                        if(paramType.type == 0) {\r\n                            return paramType.componentCount == 1 ? _tempMemUint32[0] : new Uint32Array(HEAPF32.buffer, _tempMem, paramType.componentCount);\r\n                        }\r\n                        if(paramType.type == 1) {\r\n                            return paramType.componentCount == 1 ? _tempMemInt[0] : new Int32Array(HEAPF32.buffer, _tempMem, paramType.componentCount);\r\n                        }\r\n                        if(paramType.type == 2) {\r\n                            return paramType.componentCount == 1 ? _tempMemFloat[0] : new Float32Array(HEAPF32.buffer, _tempMem, paramType.componentCount);\r\n                        }\r\n                        if(paramType.type == 3) {\r\n                            return new Texture(_tempMemInt[0]);\r\n                        }\r\n                    }\r\n                    throw new Error(`Invalid type ${paramType} on parameter ${paramIndex} for material ${target._index}`);\r\n                } else {\r\n                    return target[prop];\r\n                }\r\n            },\r\n\r\n            set(target, prop, value) {\r\n                const paramIndex = target._paramIndex(prop);\r\n                if(paramIndex >= 0) {\r\n                    if(value instanceof Texture) {\r\n                        _wl_material_set_param_value_uint(\r\n                            target._index, paramIndex, value._id);\r\n                    } else if(typeof(value) === 'number') {\r\n                        _tempMemFloat[0] = value;\r\n                        _wl_material_set_param_value_float(\r\n                            target._index, paramIndex, _tempMem, 1);\r\n                    } else {\r\n                        let length = value.length;\r\n                        for(let i = 0; i < length; ++i) {\r\n                            _tempMemFloat[i] = value[i];\r\n                        }\r\n                        _wl_material_set_param_value_float(\r\n                            target._index, paramIndex, _tempMem, length);\r\n                    }\r\n                } else {\r\n                    target[prop] = value;\r\n                }\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n};\r\nexport { Material };\r\n\r\nlet tempCanvas = null;\r\n\r\n/**\r\n * Wrapper around a native texture data\r\n */\r\nclass Texture {\r\n\r\n    /**\r\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|number} param HTML media element to create texture from or texture id to wrap.\r\n     */\r\n    constructor(param) {\r\n        if(param instanceof HTMLImageElement || param instanceof HTMLVideoElement || param instanceof HTMLCanvasElement) {\r\n            const index = _images.length;\r\n            _images.push(param);\r\n            this._imageIndex = index;\r\n            this._id = _wl_renderer_addImage(index);\r\n        } else {\r\n            this._id = param;\r\n        }\r\n        textures[this._id] = this;\r\n    }\r\n\r\n    /** @returns {boolean} Whether this texture is valid */\r\n    get valid() {\r\n        return this._id >= 0;\r\n    }\r\n\r\n    /** Update the texture to match the HTML element (e.g. reflect the current frame of a video) */\r\n    update() {\r\n        if(!this.valid) return;\r\n        _wl_renderer_updateImage(this._id, this._imageIndex);\r\n    }\r\n\r\n    /**\r\n     * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video)\r\n     *\r\n     * @param {number} x x offset\r\n     * @param {number} y y offset\r\n     * @param {number} w width\r\n     * @param {number} h height\r\n     */\r\n    updateSubImage(x, y, w, h) {\r\n        if(!this.valid) return;\r\n\r\n        /* Lazy initialize temp canvas */\r\n        if(!tempCanvas) tempCanvas = document.createElement('canvas');\r\n\r\n        const img = _images[this._imageIndex];\r\n\r\n        tempCanvas.width = w;\r\n        tempCanvas.height = h;\r\n        tempCanvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);\r\n        _images[this._imageIndex] = tempCanvas;\r\n\r\n        try {\r\n            _wl_renderer_updateImage(this._id,\r\n                this._imageIndex, x, (img.videoHeight || img.height) - y - h);\r\n        } finally {\r\n            _images[this._imageIndex] = img;\r\n        }\r\n    }\r\n};\r\nexport { Texture };\r\n\r\n/**\r\n * Access to the texures managed by Wonderland Engine\r\n */\r\nconst textures = {\r\n\r\n    /**\r\n     * Load an image from URL as {@link Texture}\r\n     * @param {string} filename URL to load from\r\n     * @param {string} crossOrigin Cross origin flag for the {@link Image} object\r\n     * @returns {Promise<Texture>} Loaded texture\r\n     */\r\n    load: function(filename, crossOrigin) {\r\n        let image = new Image();\r\n        if(crossOrigin !== undefined) {\r\n            image.crossOrigin = crossOrigin;\r\n        }\r\n        image.src = filename;\r\n        return new Promise((resolve, reject) => {\r\n            image.onload = function() {\r\n                let texture = new Texture(image);\r\n                if(!texture.valid) {\r\n                    reject(\"Failed to add image \" + image.src + \" to texture atlas. Probably incompatible format.\");\r\n                }\r\n                resolve(texture);\r\n            };\r\n        });\r\n    }\r\n};\r\n\r\n/**\r\n * Wrapper around a native animation\r\n */\r\nclass Animation {\r\n    constructor(index) {\r\n        this._index = index;\r\n    }\r\n\r\n    /** @returns {number} Duration of this animation */\r\n    get duration() {\r\n        return _wl_animation_get_duration(this._index);\r\n    }\r\n\r\n    /** @returns {number} Number of tracks in this animation */\r\n    get trackCount() {\r\n        return _wl_animation_get_trackCount(this._index);\r\n    }\r\n\r\n    /**\r\n     * Clone this animation retargeted to a new set of objects.\r\n     *\r\n     * The clone shares most of the data with the original and is therefore\r\n     * light-weight.\r\n     *\r\n     * **Experimental:** This API might change in upcoming versions.\r\n     *\r\n     * If retargetting to {@link Skin}, the join names will be used to determine a mapping\r\n     * from the previous skin to the new skin. The source skin will be retrieved from\r\n     * the first track in the animation that targets a joint.\r\n     *\r\n     * @param {$Object[]|Skin} newTargets New targets per track. Expected to have\r\n     *      {@link Animation#trackCount} elements or to be a {@link Skin}.\r\n     * @returns {Animation} The retargeted clone of this animation.\r\n     */\r\n    retarget(newTargets) {\r\n        if(newTargets instanceof Skin) {\r\n            const animId = _wl_animation_retargetToSkin(this._index, newTargets._index);\r\n            return new Animation(animId);\r\n        }\r\n\r\n        if(newTargets.length != this.trackCount) {\r\n            throw Error(\"Expected \" + this.trackCount.toString() + \" targets, but got \" + newTargets.length.toString());\r\n        }\r\n        const ptr = _malloc(2*newTargets.length);\r\n        for(let i = 0; i < newTargets.length; ++i) {\r\n            HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;\r\n        }\r\n        const animId = _wl_animation_retarget(this._index, ptr);\r\n        _free(ptr);\r\n\r\n        return new Animation(animId);\r\n    }\r\n};\r\nexport { Animation };\r\n\r\n/**\r\n * Scene graph object\r\n *\r\n * Node in the scene graph or \"entity\". Consists of transformation and a reference\r\n * to its parent object. Usually holds components and is accessible by components\r\n * through {@link Component#object}.\r\n *\r\n * Objects are stored in a data oriented mannor inside WebAssembly memory. This class\r\n * is a JavaScript API wrapper around this memory for more conventient use in\r\n * components.\r\n *\r\n * Objects can be created and added to a scene through\r\n * {@link Scene#addObject} on the {@link scene|main scene}.\r\n */\r\nclass $Object {\r\n    /**\r\n     * @param {number} o Object id to wrap\r\n     */\r\n    constructor(o) {\r\n        this.objectId = o;\r\n    }\r\n\r\n    /**\r\n     * Useful for identifying objects during debugging.\r\n     * @returns {string} Name of the object\r\n     */\r\n    get name() {\r\n        return UTF8ToString(_wl_object_name(this.objectId));\r\n    }\r\n\r\n    /**\r\n     * Set the object's name\r\n     * @param {string} newName String to the the object's name to\r\n     */\r\n    set name(newName) {\r\n        const lengthBytes = lengthBytesUTF8(newName) + 1;\r\n        const mem = _malloc(lengthBytes);\r\n        stringToUTF8(newName, mem, lengthBytes);\r\n        _wl_object_set_name(this.objectId, mem);\r\n        _free(mem);\r\n    }\r\n\r\n    /**\r\n     * @returns {$Object} Parent of this object or {@link null} if parented to root\r\n     */\r\n    get parent() {\r\n        const p = _wl_object_parent(this.objectId);\r\n        return p == 0 ? null : $Object._wrapObject(p);\r\n    }\r\n\r\n    /**\r\n     * @returns {$Object[]} Children of this object\r\n     *\r\n     * @warning This method will currently return at most 512 child objects.\r\n     */\r\n    get children() {\r\n        const childrenCount = _wl_object_get_children(this.objectId, _tempMem, _tempMemSize >> 1);\r\n        if(childrenCount == 0) return [];\r\n\r\n        const children = new Array(childrenCount);\r\n        for(let i = 0; i < childrenCount; ++i) {\r\n            children[i] = $Object._wrapObject(_tempMemUint16[i]);\r\n        }\r\n        return children;\r\n    }\r\n\r\n    /**\r\n     * Reparent object to given object.\r\n     * @param {$Object} newParent New parent or {@link null} to parent to root\r\n     * @note Reparenting is not trivial and might have a noticable performance impact\r\n     */\r\n    set parent(newParent) {\r\n        _wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);\r\n    }\r\n\r\n    /** Reset local transformation (translation, rotation and scaling) to identity */\r\n    resetTransform() {\r\n        _wl_object_reset_translation_rotation(this.objectId);\r\n        _wl_object_reset_scaling(this.objectId);\r\n    }\r\n\r\n    /** Reset local translation and rotation to identity */\r\n    resetTranslationRotation() {\r\n        _wl_object_reset_translation_rotation(this.objectId);\r\n    }\r\n\r\n    /**\r\n     * Reset local rotation, keep translation.\r\n     * @note To reset both rotation and translation, prefer\r\n     *       {@link $Object#resetTranslationRotation}.\r\n     */\r\n    resetRotation() {\r\n        _wl_object_reset_rotation(this.objectId);\r\n    }\r\n\r\n    /**\r\n     * Reset local translation, keep rotation.\r\n     * @note To reset both rotation and translation, prefer\r\n     *       {@link $Object#resetTranslationRotation}.\r\n     */\r\n    resetTranslation() {\r\n        _wl_object_reset_translation(this.objectId);\r\n    }\r\n\r\n    /** Reset local scaling to identity (``[1.0, 1.0, 1.0]``)*/\r\n    resetScaling() {\r\n        _wl_object_reset_scaling(this.objectId);\r\n    }\r\n\r\n    /**\r\n     * Translate object by a vector in the parent's space\r\n     * @param {number[]} v Vector to translate by\r\n     */\r\n    translate(v) {\r\n        _wl_object_translate(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * Translate object by a vector in object space\r\n     * @param {number[]} v Vector to translate by\r\n     */\r\n    translateObject(v) {\r\n        _wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * Translate object by a vector in world space\r\n     * @param {number[]} v Vector to translate by\r\n     */\r\n    translateWorld(v) {\r\n        _wl_object_translate_world(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * Rotate around given axis by given angle (degrees) in local space\r\n     * @param {number[]} a Vector representing the rotation axis\r\n     * @param {number} d Angle in degrees\r\n     *\r\n     * @note If the object is translated the rotation will be around\r\n     *     the parent. To rotate around the object origin, use\r\n     *     {@link $Object#rotateAxisAngleDegObject}\r\n     *\r\n     * @see {@link $Object#rotateAxisAngleRad}\r\n     */\r\n    rotateAxisAngleDeg(a, d) {\r\n        _wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);\r\n    }\r\n\r\n    /**\r\n     * Rotate around given axis by given angle (radians) in local space\r\n     * @param {number[]} a Vector representing the rotation axis\r\n     * @param {number} d Angle in degrees\r\n     *\r\n     * @note If the object is translated the rotation will be around\r\n     *     the parent. To rotate around the object origin, use\r\n     *     {@link $Object#rotateAxisAngleDegObject}\r\n     *\r\n     * @see {@link $Object#rotateAxisAngleDeg}\r\n     */\r\n    rotateAxisAngleRad(a, d) {\r\n        _wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);\r\n    }\r\n\r\n    /**\r\n     * Rotate around given axis by given angle (degrees) in object space\r\n     * @param {number[]} a Vector representing the rotation axis\r\n     * @param {number} d Angle in degrees\r\n     *\r\n     * Equivalent to prepending a rotation quaternion to the object's\r\n     * local transformation.\r\n     *\r\n     * @see {@link $Object#rotateAxisAngleRadObject}\r\n     */\r\n    rotateAxisAngleDegObject(a, d) {\r\n        _wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);\r\n    }\r\n\r\n    /**\r\n     * Rotate around given axis by given angle (radians) in object space\r\n     * Equivalent to prepending a rotation quaternion to the object's\r\n     * local transformation.\r\n     *\r\n     * @param {number[]} a Vector representing the rotation axis\r\n     * @param {number} d Angle in degrees\r\n     *\r\n     * @see {@link $Object#rotateAxisAngleDegObject}\r\n     */\r\n    rotateAxisAngleRadObject(a, d) {\r\n        _wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);\r\n    }\r\n\r\n    /**\r\n     * Rotate by a quaternion\r\n     * @param {number[]} q the Quaternion to rotate by\r\n     */\r\n    rotate(q) {\r\n        _wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);\r\n    }\r\n\r\n    /**\r\n     * Rotate by a quaternion in object space\r\n     *\r\n     * Equivalent to prepending a rotation quaternion to the object's\r\n     * local transformation.\r\n     *\r\n     * @param {number[]} q the Quaternion to rotate by\r\n     */\r\n    rotateObject(q) {\r\n        _wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);\r\n    }\r\n\r\n    /**\r\n     * Scale object by a vector in object space\r\n     *\r\n     * @param {number[]} v Vector to scale by\r\n     */\r\n    scale(v) {\r\n        _wl_object_scale(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n\r\n    /** @returns {Float32Array} Local / object space transformation */\r\n    get transformLocal() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_object_trans_local(this.objectId), 8);\r\n    }\r\n\r\n    /**\r\n     * Set world transform.\r\n     *\r\n     * @param {number} t Local space transformation\r\n     *\r\n     * @since 0.8.5\r\n     */\r\n    set transformLocal(t) {\r\n        this.transformLocal.set(t);\r\n        this.setDirty();\r\n    }\r\n\r\n    /**\r\n     * Compute local / object space translation from transformation\r\n     * @param {number[]} out Destination array/vector, expected to have at\r\n     *                       least 3 elements.\r\n     * @return {number[]} out\r\n     */\r\n    getTranslationLocal(out) {\r\n        _wl_object_get_translation_local(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Compute local / object space translation from transformation\r\n     *\r\n     * May recompute transformations of the hierarchy of this object,\r\n     * if they were been by JavaScript components this frame.\r\n     *\r\n     * @param {number[]} out Destination array/vector, expected to have at\r\n     *                       least 3 elements.\r\n     * @return {number[]} out\r\n     */\r\n    getTranslationWorld(out) {\r\n        _wl_object_get_translation_world(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Set local / object space translation\r\n     *\r\n     * Concatenates a new translation dual quaternion onto the existing rotation.\r\n     *\r\n     * @param {number[]} v New local translation array/vector, expected to\r\n     *                       have at least 3 elements.\r\n     *\r\n     */\r\n    setTranslationLocal(v) {\r\n        _wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * Set world space translation\r\n     *\r\n     * Applies the inverse parent transform with a new translation dual quaternion\r\n     * which is concatenated onto the existing rotation.\r\n     *\r\n     * @param {number[]} v New world translation array/vector, expected to\r\n     *                       have at least 3 elements.\r\n     */\r\n    setTranslationWorld(v) {\r\n        _wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);\r\n    }\r\n\r\n    /**\r\n     * May recompute transformations of the hierarchy of this object,\r\n     * if they were been by JavaScript components this frame.\r\n     *\r\n     * @returns {Float32Array} Global / world space transformation\r\n     */\r\n    get transformWorld() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_object_trans_world(this.objectId), 8);\r\n    }\r\n\r\n    /**\r\n     * Set world transform.\r\n     *\r\n     * @param {number} t Global / world space transformation\r\n     *\r\n     * @since 0.8.5\r\n     */\r\n    set transformWorld(t) {\r\n        this.transformWorld.set(t);\r\n        _wl_object_trans_world_to_local(this.objectId);\r\n    }\r\n\r\n    /** @returns {Float32Array} Local / object space scaling */\r\n    get scalingLocal() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_object_scaling_local(this.objectId), 3);\r\n    }\r\n\r\n    /**\r\n     * Set scaling local\r\n     *\r\n     * @param {number[]} t Global / world space transformation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    set scalingLocal(s) {\r\n        this.scalingLocal.set(s);\r\n        this.setDirty();\r\n    }\r\n\r\n    /**\r\n     * @returns {Float32Array} Global / world space scaling\r\n     *\r\n     * May recompute transformations of the hierarchy of this object,\r\n     * if they were been by JavaScript components this frame.\r\n     */\r\n    get scalingWorld() {\r\n        return new Float32Array(HEAPF32.buffer, _wl_object_scaling_world(this.objectId), 3);\r\n    }\r\n\r\n    /**\r\n     * Set scaling world\r\n     *\r\n     * @param {number[]} t Global / world space transformation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    set scalingWorld(s) {\r\n        this.scalingWorld.set(s);\r\n        _wl_object_scaling_world_to_local(this.objectId);\r\n    }\r\n\r\n    /**\r\n     * @returns {number[]} Local space rotation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    get rotationLocal() {\r\n        return this.transformLocal.subarray(0, 4);\r\n    }\r\n\r\n    /**\r\n     * @returns {number[]} Global / world space rotation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    get rotationWorld() {\r\n        return this.transformWorld.subarray(0, 4);\r\n    }\r\n\r\n    /**\r\n     * Set rotation local\r\n     *\r\n     * @param {number} r Local space rotation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    set rotationLocal(r) {\r\n        _wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);\r\n    }\r\n\r\n    /**\r\n     * Set rotation world\r\n     *\r\n     * @param {number} r Global / world space rotation\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    set rotationWorld(r) {\r\n        _wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);\r\n    }\r\n\r\n    /**\r\n     * Compute the object's forward facing world space vector\r\n     * @param {number[]} out Destination array/vector, expected to have at\r\n     *                       least 3 elements.\r\n     * @return {number[]} out\r\n     */\r\n    getForward(out) {\r\n        out[0] = 0; out[1] = 0; out[2] = -1;\r\n        this.transformVectorWorld(out);\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Compute the object's up facing world space vector\r\n     * @param {number[]} out Destination array/vector, expected to have at\r\n     *                       least 3 elements.\r\n     * @return {number[]} out\r\n     */\r\n    getUp(out) {\r\n        out[0] = 0; out[1] = 1; out[2] = 0;\r\n        this.transformVectorWorld(out);\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Compute the object's right facing world space vector\r\n     * @param {number[]} out Destination array/vector, expected to have at\r\n     *                       least 3 elements.\r\n     * @return {number[]} out\r\n     */\r\n    getRight(out) {\r\n        out[0] = 1; out[1] = 0; out[2] = 0;\r\n        this.transformVectorWorld(out);\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a vector by this object's world transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformVectorWorld(out, v) {\r\n        v = v || out;\r\n        _tempMemFloat[0] = v[0];\r\n        _tempMemFloat[1] = v[1];\r\n        _tempMemFloat[2] = v[2];\r\n        _wl_object_transformVectorWorld(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a vector by this object's local transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformVectorLocal(out, v) {\r\n        v = v || out;\r\n        _tempMemFloat[0] = v[0];\r\n        _tempMemFloat[1] = v[1];\r\n        _tempMemFloat[2] = v[2];\r\n        _wl_object_transformVectorLocal(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a point by this object's world transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformPointWorld(out, p) {\r\n        p = p || out;\r\n        _tempMemFloat[0] = p[0];\r\n        _tempMemFloat[1] = p[1];\r\n        _tempMemFloat[2] = p[2];\r\n        _wl_object_transformPointWorld(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a point by this object's local transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformPointLocal(out, p) {\r\n        p = p || out;\r\n        _tempMemFloat[0] = p[0];\r\n        _tempMemFloat[1] = p[1];\r\n        _tempMemFloat[2] = p[2];\r\n        _wl_object_transformPointLocal(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a vector by this object's inverse world transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformVectorInverseWorld(out, v) {\r\n        v = v || out;\r\n        _tempMemFloat[0] = v[0];\r\n        _tempMemFloat[1] = v[1];\r\n        _tempMemFloat[2] = v[2];\r\n        _wl_object_transformVectorInverseWorld(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a point by this object's inverse local transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformVectorInverseLocal(out, v) {\r\n        v = v || out;\r\n        _tempMemFloat[0] = v[0];\r\n        _tempMemFloat[1] = v[1];\r\n        _tempMemFloat[2] = v[2];\r\n        _wl_object_transformVectorInverseLocal(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a point by this object's inverse world transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} v Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformPointInverseWorld(out, p) {\r\n        p = p || out;\r\n        _tempMemFloat[0] = p[0];\r\n        _tempMemFloat[1] = p[1];\r\n        _tempMemFloat[2] = p[2];\r\n        _wl_object_transformPointInverseWorld(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a point by this object's inverse local transform\r\n     *\r\n     * @param {number[]} out Out point\r\n     * @param {number[]} p Point to transform, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    transformPointInverseLocal(out, p) {\r\n        p = p || out;\r\n        _tempMemFloat.set(p);\r\n        _wl_object_transformPointInverseLocal(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a object space dual quaternion into world space\r\n     *\r\n     * @param {number[]} out Out transformation\r\n     * @param {number[]} q Local space transformation, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    toWorldSpaceTransform(out, q) {\r\n        q = q || out;\r\n        _tempMemFloat.set(q);\r\n        _wl_object_toWorldSpaceTransform(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n        out[3] = _tempMemFloat[3];\r\n\r\n        out[4] = _tempMemFloat[4];\r\n        out[5] = _tempMemFloat[5];\r\n        out[6] = _tempMemFloat[6];\r\n        out[7] = _tempMemFloat[7];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a world space dual quaternion into local space\r\n     *\r\n     * @param {number[]} out Out transformation\r\n     * @param {number[]} q World space transformation, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    toLocalSpaceTransform(out, q) {\r\n        const p = this.parent;\r\n        if(!p) {\r\n            out[0] = q[0]; out[1] = q[1]; out[2] = q[2]; out[3] = q[3];\r\n            out[4] = q[4]; out[5] = q[5]; out[6] = q[6]; out[7] = q[7];\r\n        } else {\r\n            p.toObjectSpaceTransform(q);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Transform a world space dual quaternion into object space\r\n     *\r\n     * @param {number[]} out Out transformation\r\n     * @param {number[]} q World space transformation, default `out`\r\n     * @return {number[]} out\r\n     *\r\n     * @since 0.8.7\r\n     */\r\n    toObjectSpaceTransform(out, q) {\r\n        q = q || out;\r\n        _tempMemFloat.set(q);\r\n        _wl_object_toObjectSpaceTransform(this.objectId, _tempMem);\r\n        out[0] = _tempMemFloat[0];\r\n        out[1] = _tempMemFloat[1];\r\n        out[2] = _tempMemFloat[2];\r\n        out[3] = _tempMemFloat[3];\r\n\r\n        out[4] = _tempMemFloat[4];\r\n        out[5] = _tempMemFloat[5];\r\n        out[6] = _tempMemFloat[6];\r\n        out[7] = _tempMemFloat[7];\r\n\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Turn towards / look at target\r\n     * @param {number[]} v Target vector to turn towards\r\n     * @param {number[]} up Up vector of this object, default `[0, 1, 0]`\r\n     */\r\n    lookAt(v, up=[0, 1, 0]) {\r\n        _wl_object_lookAt(this.objectId,\r\n            v[0], v[1], v[2], up[0], up[1], up[2]);\r\n    }\r\n\r\n    /** Destroy the object and remove it from the scene */\r\n    destroy() {\r\n        _wl_scene_remove_object(this.objectId);\r\n        this.objectId = null;\r\n    }\r\n\r\n    /**\r\n     * Mark transformation dirty\r\n     *\r\n     * Causes an eventual recalculation of {@link $Object#transformWorld}, either\r\n     * on next {@link $Object#getTranslationWorld}, {@link $Object#transformWorld} or\r\n     * {@link $Object#scalingWorld} or the beginning of next frame, whichever\r\n     * happens first.\r\n     */\r\n    setDirty() {\r\n        _wl_object_set_dirty(this.objectId);\r\n    }\r\n\r\n    /**\r\n     * Disable/enable all components of this object\r\n     *\r\n     * @param {boolean} b New state for the components\r\n     * @since 0.8.5\r\n     */\r\n    set active(b) {\r\n        const comps = this.getComponents();\r\n        for(let c of comps) {\r\n            c.active = b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a component attached to this object\r\n     * @param {string} type Type name\r\n     * @param {number} index=0 Index for component of given type. This can be used to access specific\r\n     *      components if the object has multiple components of the same type.\r\n     * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if there is no such component on this object\r\n     */\r\n    getComponent(type, index) {\r\n        const lengthBytes = lengthBytesUTF8(type) + 1;\r\n        const mem = _malloc(lengthBytes);\r\n        stringToUTF8(type, mem, lengthBytes);\r\n        const componentType = _wl_get_component_manager_index(mem);\r\n\r\n        if(componentType < 0) {\r\n            /* Not a native component, try js: */\r\n            const jsIndex = _wl_get_js_component_index(this.objectId, mem, index || 0);\r\n            _free(mem);\r\n            return jsIndex < 0 ? null : _WL._components[jsIndex];\r\n        }\r\n        _free(mem);\r\n\r\n        const componentId = _wl_get_component_id(this.objectId, componentType, index || 0);\r\n        return $Object._wrapComponent(type, componentType, componentId);\r\n    }\r\n\r\n    /**\r\n     * @param {?string} type Type name, pass a falsey value (`undefined` or {@link null}) to retrieve all\r\n     * @returns {Component[]} All components of given type attached to this object\r\n     *\r\n     * @warning This method will currently return at most 341 components.\r\n     */\r\n    getComponents(type) {\r\n        const componentType = type ? $Object._typeIndexFor(type) : null;\r\n\r\n        const components = [];\r\n        const maxComps = Math.floor(_tempMemSize/3*2);\r\n        const componentsCount =\r\n            _wl_object_get_components(this.objectId, _tempMem, maxComps);\r\n        const offset = 2*componentsCount;\r\n        _wl_object_get_component_types(this.objectId, _tempMem + offset, maxComps);\r\n\r\n        const jsManagerIndex = $Object._typeIndexFor('js');\r\n        for(let i = 0; i < componentsCount; ++i) {\r\n            const t = _tempMemUint8[i + offset];\r\n            const componentId = _tempMemUint16[i];\r\n            /* Handle JS types separately */\r\n            if(t == jsManagerIndex) {\r\n                const comp = _WL._components[_wl_get_js_component_index_for_id(componentId)];\r\n                if(componentType === null || comp.type == type) components.push(comp);\r\n                continue;\r\n            }\r\n\r\n            if(componentType === null) {\r\n                const managerName = $Object._typeNameFor(t);\r\n                components.push($Object._wrapComponent(\r\n                    managerName, t, componentId));\r\n            } else if(t == componentType) {\r\n                /* Optimized manager name retrieval, already have type */\r\n                components.push($Object._wrapComponent(\r\n                    type, componentType, componentId));\r\n            }\r\n        }\r\n        return components;\r\n    }\r\n\r\n    /**\r\n     * Add component of given type to the object\r\n     *\r\n     * @param {string} type Typename to create a component of. Can be native or\r\n     *      custom JavaScript component type.\r\n     * @param {object} [params] Parameters to initialize properties of the new component\r\n     *\r\n     * @note As this function is non-trivial, avoid using it in `update()` repeatidly, but rather\r\n     *  store its result in `init()` or `start()`\r\n     * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if the type was not found\r\n     */\r\n    addComponent(type, params) {\r\n        const componentType = $Object._typeIndexFor(type);\r\n        if(componentType < 0) {\r\n            if(!(type in _WL._componentTypeIndices)) {\r\n                throw new TypeError(\"Unknown component type '\" + type + \"'\");\r\n            }\r\n            const componentId = _wl_object_add_js_component(this.objectId, _WL._componentTypeIndices[type]);\r\n            const componentIndex = _wl_get_js_component_index_for_id(componentId);\r\n            let component = _WL._components[componentIndex];\r\n            if(params !== undefined) {\r\n                for(key in params) {\r\n                    /* active will be set later */\r\n                    if(key == 'active') continue;\r\n                    component[key] = params[key];\r\n                }\r\n            }\r\n            _wljs_component_init(componentIndex);\r\n            /* start() is called through onActivate() */\r\n\r\n            /* If it was not explicitly requested by the user to leave the component inactive,\r\n             * we activate it as a final step. This invalidates componentIndex! */\r\n            if(!params || !('active' in params && !params.active)) {\r\n                component.active = true;\r\n            }\r\n\r\n            return component;\r\n        }\r\n        const componentId = _wl_object_add_component(this.objectId, componentType);\r\n\r\n        const component = $Object._wrapComponent(type, componentType, componentId);\r\n        if(params !== undefined) {\r\n            for(key in params) {\r\n                component[key] = params[key];\r\n            }\r\n        }\r\n\r\n        if(!params || !('active' in params && !params.active)) {\r\n            component.active = true;\r\n        }\r\n\r\n        return component;\r\n    }\r\n\r\n    /**\r\n     * Checks equality by comparing whether the wrapped native component ids\r\n     * and component manager types are equal.\r\n     *\r\n     * @param {?$Object} otherObject Object to check equality with\r\n     * @returns {boolean} Whether this object equals the given object\r\n     */\r\n    equals(otherObject) {\r\n        if(!otherObject) return false;\r\n        return this.objectId == otherObject.objectId;\r\n    }\r\n\r\n    static _typeIndexFor(type) {\r\n        const lengthBytes = lengthBytesUTF8(type) + 1;\r\n        const mem = _malloc(lengthBytes);\r\n        stringToUTF8(type, mem, lengthBytes);\r\n        const componentType = _wl_get_component_manager_index(mem);\r\n        _free(mem);\r\n\r\n        return componentType;\r\n    }\r\n\r\n    static _typeNameFor(typeIndex) {\r\n        return UTF8ToString(_wl_component_manager_name(typeIndex));\r\n    }\r\n\r\n    /*\r\n     * @param {string} type component type name\r\n     * @param {number} componentType Component manager index\r\n     * @param {number} componentId Component id in the manager\r\n     * @returns {(CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} JavaScript instance wrapping the native component\r\n     */\r\n    static _wrapComponent(type, componentType, componentId) {\r\n        if(componentId < 0) return null;\r\n\r\n        const c = ComponentCache[componentType] || (ComponentCache[componentType] = []);\r\n        if(type == 'collision') {\r\n            return (c[componentId] || (c[componentId] = new CollisionComponent(componentType, componentId)));\r\n        } else if(type == 'text') {\r\n            return (c[componentId] || (c[componentId] = new TextComponent(componentType, componentId)));\r\n        } else if(type == 'view') {\r\n            return (c[componentId] || (c[componentId] = new ViewComponent(componentType, componentId)));\r\n        } else if(type == 'mesh') {\r\n            return (c[componentId] || (c[componentId] = new MeshComponent(componentType, componentId)));\r\n        } else if(type == 'input') {\r\n            return (c[componentId] || (c[componentId] = new InputComponent(componentType, componentId)));\r\n        } else if(type == 'light') {\r\n            return (c[componentId] || (c[componentId] = new LightComponent(componentType, componentId)));\r\n        } else if(type == 'animation') {\r\n            return (c[componentId] || (c[componentId] = new AnimationComponent(componentType, componentId)));\r\n        } else if(type == 'physx') {\r\n            return (c[componentId] || (c[componentId] = new PhysXComponent(componentType, componentId)));\r\n        } else {\r\n            return (c[componentId] || (c[componentId] = new Component(componentType, componentId)));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @param {number} objectId Object ID to wrap\r\n     * @returns {$Object} Wrapped object\r\n     */\r\n    static _wrapObject(objectId) {\r\n        const o = ObjectCache[objectId] || (ObjectCache[objectId] = new $Object(objectId));\r\n        o.objectId = objectId;\r\n        return o;\r\n    }\r\n};\r\n\r\n/**\r\n * Wrapper around a native skin data\r\n */\r\nclass Skin {\r\n    constructor(index) {\r\n        this._index = index;\r\n    }\r\n\r\n    /** @returns {number} amount of joints in this skin */\r\n    get jointCount() {\r\n        return _wl_skin_get_joint_count(this._index);\r\n    }\r\n\r\n    /** @returns {Uint16Array} joints object ids for this skin */\r\n    get jointIds() {\r\n        return new Uint16Array(HEAPU16.buffer,\r\n            _wl_skin_joint_ids(this._index), this.jointCount);\r\n    }\r\n\r\n    /**\r\n     * Dual quaternions in a flat array of size 8 times {@link Skin#jointCount}\r\n     *\r\n     * @returns {Float32Array} Inverse bind transforms of the skin\r\n     */\r\n    get inverseBindTransforms() {\r\n        return new Float32Array(HEAPF32.buffer,\r\n            _wl_skin_inverse_bind_transforms(this._index),\r\n            8*this.jointCount);\r\n    }\r\n\r\n    /**\r\n     * Vectors in a flat array of size 3 times {@link Skin#jointCount}\r\n     *\r\n     * @returns {Float32Array} Inverse bind scalings of the skin\r\n     */\r\n    get inverseBindScalings() {\r\n        return new Float32Array(HEAPF32.buffer,\r\n            _wl_skin_inverse_bind_scalings(this._index),\r\n            3*this.jointCount);\r\n    }\r\n};\r\nexport { Skin };\r\n/* Unfortunately, the name \"Object\" is reserved, so internally we\r\n * use $Object, while we expose WL.Object as previously. */\r\nexport { $Object as Object };\r\n\r\n/**\r\n * @summary Ray hit\r\n *\r\n * Result of a {@link Scene#rayCast|ray cast}\r\n *\r\n * @param {number} ptr Pointer to the ray hits memory\r\n * @note this class wraps internal engine data and should only be created\r\n * internally.\r\n */\r\nclass RayHit {\r\n    constructor(ptr) {\r\n        assert((this._ptr & 3) == 0, MISALIGNED_MSG);\r\n        this._ptr = ptr;\r\n    }\r\n\r\n    /** @returns {Float32Array[]} array of ray hit locations */\r\n    get locations() {\r\n        let p = this._ptr;\r\n        let l = [];\r\n        for(let i = 0; i < this.hitCount; ++i) {\r\n            l.push(new Float32Array(HEAPF32.buffer, p + 12*i, 3));\r\n        }\r\n        return l;\r\n    }\r\n\r\n    /** @returns {Float32Array[]} array of ray hit normals (only when using {@link Physics#rayCast} */\r\n    get normals() {\r\n        let p = this._ptr + 48;\r\n        let l = [];\r\n        for(let i = 0; i < this.hitCount; ++i) {\r\n            l.push(new Float32Array(HEAPF32.buffer, p + 12*i, 3));\r\n        }\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Prefer these to recalculating the distance from locations.\r\n     *\r\n     * @returns {number} Distances of array hits to ray origin\r\n     */\r\n    get distances() {\r\n        let p = this._ptr + 48*2;\r\n        return new Float32Array(HEAPF32.buffer, p, this.hitCount);\r\n    }\r\n\r\n    /** @returns {$Object[]} Hit objects */\r\n    get objects() {\r\n        let p = this._ptr + (48*2 + 16);\r\n        let objIds = new Uint16Array(HEAPU16.buffer, p, this.hitCount);\r\n        return [\r\n            objIds[0] <= 0 ? null : $Object._wrapObject(objIds[0]),\r\n            objIds[1] <= 0 ? null : $Object._wrapObject(objIds[1]),\r\n            objIds[2] <= 0 ? null : $Object._wrapObject(objIds[2]),\r\n            objIds[3] <= 0 ? null : $Object._wrapObject(objIds[3]),\r\n        ];\r\n    }\r\n\r\n    /** @returns {number} Number of hits (max 4) */\r\n    get hitCount() {\r\n        return Math.min(HEAPU32[(this._ptr/4) + 30], 4);\r\n    }\r\n};\r\nexport { RayHit };\r\n\r\nclass math {\r\n    /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.\r\n     *\r\n     * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.\r\n     *\r\n     * Whether a quaternion or vector3 interpolation is intended is determined by\r\n     * legth of `a`.\r\n     *\r\n     * @param {number[]} out Array to write result to\r\n     * @param {number[]} a First tangent/handle\r\n     * @param {number[]} b First point or quaternion\r\n     * @param {number[]} c Second point or quaternion\r\n     * @param {number[]} d Second handle\r\n     * @param {number} f Interpolation factor in [0; 1]\r\n     * @returns {number[]} out\r\n     * @since 0.8.6\r\n     */\r\n    static cubicHermite(out, a, b, c, d, f) {\r\n        _tempMemFloat.subarray(0).set(a);\r\n        _tempMemFloat.subarray(4).set(b);\r\n        _tempMemFloat.subarray(8).set(c);\r\n        _tempMemFloat.subarray(12).set(d);\r\n\r\n        const isQuat = a.length == 4;\r\n\r\n        _wl_math_cubicHermite(\r\n            _tempMem + 4*16,\r\n            _tempMem + 4*0,\r\n            _tempMem + 4*4,\r\n            _tempMem + 4*8,\r\n            _tempMem + 4*12,\r\n            f, isQuat);\r\n        out[0] = _tempMemFloat[16];\r\n        out[1] = _tempMemFloat[17];\r\n        out[2] = _tempMemFloat[18];\r\n        if(isQuat) out[3] = _tempMemFloat[19];\r\n        return out;\r\n    }\r\n}\r\n\r\nexport { math }\r\n"],
  "mappings": "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",
  "names": []
}
